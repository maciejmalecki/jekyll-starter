<!DOCTYPE html>
<html>

<head>
	

	<!-- Meta -->
	<meta charset="UTF-8"/>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
	<meta name="generator" content="Jekyll">

	<title>Building blocks</title>
  <meta name="description" content="The major building blocks of the `c64lib`.">

	<!-- CSS & fonts -->
	<link rel="stylesheet" href="/jekyll-starter/css/main.css">

	<!-- RSS -->
	<link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" />

  <!-- Favicon -->
  <link rel="shortcut icon" type="image/png" href="/jekyll-starter/img/favicon.png">

</head>


<body>
	<div id="wrap">

	  	<!-- Navigation -->
	  	<nav id="nav">
	<div id="nav-list">
		<a href="/jekyll-starter/">Home</a>

		<!-- Nav pages -->
		
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	      <a href="/jekyll-starter/pages/about" title="About">About</a>
	    
	  
	    
	      <a href="/jekyll-starter/pages/install" title="Installation guide">Install</a>
	    
	  
	    
	      <a href="/jekyll-starter/news/" title="News">News</a>
	    
	  
	    
	      <a href="/jekyll-starter/pages/contribute" title="Contribute">Contribute</a>
	    
	  

    <!-- Nav links -->
	  <a href="https://github.com/c64lib">Github</a>


	</div>

  <!-- Nav footer -->
	
	  <footer>

</footer>

	

</nav>


    <!-- Icon menu -->
	  <a id="nav-menu">
	  	<div id="menu"></div>
	  </a>

      <!-- Header -->
      
        <header id="header" class="parent justify-spaceBetween">
  <div class="inner w100 relative">
    <span class="f-left">
      <a href="/jekyll-starter/">
          <h1><code>c64lib</code></h1>
      </a>
    </span>
    <span id="nav-links" class="absolute right bottom">
      <!-- Nav pages -->
      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	        <a href="/jekyll-starter/pages/about" title="About">About</a>
	      
	    
	      
	        <a href="/jekyll-starter/pages/install" title="Installation guide">Install</a>
	      
	    
	      
	        <a href="/jekyll-starter/news/" title="News">News</a>
	      
	    
	      
	        <a href="/jekyll-starter/pages/contribute" title="Contribute">Contribute</a>
	      
	    

      <!-- Nav links -->
	    <a href="https://github.com/c64lib">Github</a>


    </span>
  </div>
</header>




      

    <!-- Main content -->
	  <div id="container">

		<main>

			<article id="page">
  

  <h1>Building blocks</h1>
  <p>There are plenty of elements that can be declared within library and then
reused. In most cases a dedicated Kick Assembler syntactic elements are used.
These elements are declared source files (<code class="highlighter-rouge">asm</code>) which can be used by your
programs by using <code class="highlighter-rouge">#import</code> directive.</p>

<p>Most of the library source files have <code class="highlighter-rouge">#importonce</code> flag set - that is given
library file can be imported in many places (in direct or indirect way) and
only first import is effective. That also means that libraries can import
themselves (and in fact they do!).</p>

<p>This document describes all kinds of elements that are declared by <code class="highlighter-rouge">c64lib</code>.</p>

<h2 id="namespace">Namespace</h2>
<p>All elements of <code class="highlighter-rouge">c64lib</code> are defined within <code class="highlighter-rouge">c64lib</code> namespace, that is,
they are visible only inside this namespace. This approach prevents possible
name clashes between possible other libraries that could be used together
with <code class="highlighter-rouge">c64lib</code> in a project.</p>

<h2 id="label">Label</h2>
<p>A label is a value tagged with name. Labels are used to give symbolic names
to values denoting addresses, registers or constants.
Labels are useful to define memory locations and are widely used in <a href="https://github.com/c64lib/chipset">chipset</a> 
library:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.label VIC2                 = $D000 
.label SPRITE_0_X           = VIC2 + $00 
.label SPRITE_0_Y           = VIC2 + $01 
.label SPRITE_1_X           = VIC2 + $02 
.label SPRITE_1_Y           = VIC2 + $03 
.label SPRITE_2_X           = VIC2 + $04 
.label SPRITE_2_Y           = VIC2 + $05 
</code></pre></div></div>

<p>Labels are always declared inside <code class="highlighter-rouge">c64lib</code> namespace.
Labels can be reached outside <code class="highlighter-rouge">c64lib</code> namespace by prefixing their names with
namespace name (labels are the only elements that can be accessed that way due
to Kick Assembler limitations). For example: at any time it is legal to write:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lda #100
sta c64lib.SPRITE_0_X
</code></pre></div></div>

<h2 id="function">Function</h2>
<p>A function is an element of Kick Assembler that is declared using
<code class="highlighter-rouge">.function</code> keyword. Functions does not assemble into any machine code -
they are used by assembler to evaluate values that can be then used 
in other functions, macros or to assembly a code.</p>

<p>Example of function that negates (inverts all bits) of its argument:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.function neg(value) {
  .return value ^ $FF
}
</code></pre></div></div>

<p>Example of function that calculates packed value of memory register based 
on its arguments:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
 * Params:
 * video: location of video ram: 0..15
 * bitmap: location of bitmap definition: 0..1
 */
.function getBitmapMemory(video, bitmap) {
  .return bitmap&lt;&lt;3 | video&lt;&lt;4
}
</code></pre></div></div>

<p>Functions are always declared inside <code class="highlighter-rouge">c64lib</code> namespace. Functions are
declared in files <code class="highlighter-rouge">.asm</code> files located under <code class="highlighter-rouge">lib</code> directory.</p>

<h2 id="macro">Macro</h2>
<p>A macro is an element of Kick Assembler that is declared using <code class="highlighter-rouge">.macro</code>
directive. Once used, macro is replaced with assembly code defining it.
Macros can be parametrised (that is, they can take an argument, or even
more arguments) - this parametrisation can affect the code being
generated.</p>

<p>It is noteworthy that macro is not an equivalent of subroutine, 
even though it looks similar to one from syntactic point of view. 
When macro is “called”:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>someFancyMacro(parameter1, parameter2)
</code></pre></div></div>

<p>it does not mean, that your code will jump into place where macro 
<code class="highlighter-rouge">someFancyMacro</code> is declared, pass both parameters and return from that 
place once execution is finished. Instead, an assembler will paste
code declared inside macro substituting parameters with values provided
as <code class="highlighter-rouge">parameter1</code> and <code class="highlighter-rouge">parameter2</code>.</p>

<p>Under some circumstances you can use macros as subroutines. This may be fast, 
because there is no subroutine calling overhead. This will however consume a
lot of memory (in sense of generated machine code) if not used wisely.</p>

<p>Macros are declared in <code class="highlighter-rouge">.asm</code> files located under <code class="highlighter-rouge">lib</code> directory.</p>

<h2 id="subroutine">Subroutine</h2>
<p>As subroutine we understand a piece of ML code that can be used by jumping
there with <code class="highlighter-rouge">jsr</code> operation. A subroutine always ends with <code class="highlighter-rouge">rts</code> which means
that at the end of execution program counter will be restored to the position
right after original <code class="highlighter-rouge">jsr</code> operation and code execution will continue. In
this sense a subroutine is an equivalent of procedure, function or method in
high level programming languages.</p>

<p>Kick Assembler as such does not provide any special means to create
subroutines as it is just a macro assembler. With <code class="highlighter-rouge">c64lib</code> we basically share
subroutine code just by writing piece of asm code and place it in separate
source files.</p>

<p>Subroutines are declared in <code class="highlighter-rouge">.asm</code> files located under <code class="highlighter-rouge">lib/dir</code> subdirectory.
Each subroutine consists of appropriate <code class="highlighter-rouge">rts</code> operation so that it should always
be accessed with corresponding <code class="highlighter-rouge">jsr</code> operation. If soubroutine consumes input
parameters, they should be set accordingly before <code class="highlighter-rouge">jsr</code> is executed.
Depending on the parameter passing method it should be either register setup
(that is A, X or Y), memory location setup or pushing to the stack. For stack
method there is a convenience library <a href="https://github.com/c64lib/common/blob/master/lib/invoke.asm">invoke</a> available.</p>

<p>A subroutine code should be imported in place where it needs to be 
located - we don’t do it at the top of the source file but rather we use 
<code class="highlighter-rouge">#import</code> directive exactly in place where we want to have our subroutine.</p>

<p>Lets consider <a href="https://github.com/c64lib/common/blob/master/lib/sub/copy-large-mem-forward.asm">copyLargeMemForward</a> subroutine as an example. We have to label
a place in memory where the subroutine will start and then import the
subroutine itself:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>copyMemFwd:
    #import "common/lib/sub/copyLargeMemForward.asm"
</code></pre></div></div>

<p>The subroutine takes three parameters using stack passing method:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Stack WORD - source address
Stack WORD - target address
Stack WORD - size
</code></pre></div></div>

<p>So, before calling subroutine, you have to push 6 bytes to the stack. The
easiest way to do it is to use <a href="https://github.com/c64lib/common/blob/master/lib/invoke.asm">invoke</a> library:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#import "common/lib/invoke-global.asm"
</code></pre></div></div>

<p>and then:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>c64lib_pushParamW(sourceAddress)
c64lib_pushParamW(destinationAddress)
c64lib_pushParamW(amountOfBytesToCopy)
jsr copyMemFwd
</code></pre></div></div>

<p>In result a subroutine will be called and <code class="highlighter-rouge">amountOfBytesToCopy</code> bytes will be
copied from <code class="highlighter-rouge">sourceAddress</code> location to the <code class="highlighter-rouge">destinationAddress</code> location.</p>

<h2 id="macro-hosted-subroutine">Macro-hosted subroutine</h2>
<p>Some subroutines use this convenient method of distribution. Instead of being 
declared in separate source file, they are declared where macros and functions
are declared - in library source files itself.</p>

<p>Macro-hosted subroutines are used when further parametrisation is needed before
subroutine is ready to use. Usually there are some variants that can be turned
on or off (in such case such macro can be called multiple times thus generating
multiple versions of subroutine). Sometimes subroutine requires some zero-page
addresses that we don’t want to hardcode in the library - it would be then
up to the user to parametrise subroutine with addresses of choice.</p>

<p>Example - a scroll subroutine</p>

<p>Let’s consider <a href="https://github.com/c64lib/text/blob/develop/lib/scroll1x1.asm">scroll1x1</a>:</p>

<p>This subroutine requires three parameters being passed via stack but also needs
two consecutive bytes on zero page for functioning (indirect addressing is
used). Let’s assume we will use address 4 and 5 for this purpose.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#import "text/lib/scroll1x1.asm"
#import "common/lib/invoke.asm"

...

.namespace c64lib {
    pushParamW(screenAddress)
    pushParamW(textAddress)
    pushParamWInd(scrollPtr)
}
jsr scroll

...

scroll: .namespace c64lib { scroll1x1(4) }
</code></pre></div></div>

<p>So, the scroll subroutine is configured for address 4 (and 5), and installed
under address denoted by <code class="highlighter-rouge">scroll</code> label. It can be then normally called with
<code class="highlighter-rouge">jsr scroll</code>. Before calling input parameters need to be pushed to the stack.
It is done via <code class="highlighter-rouge">pushParamW</code> macros (for address values) and <code class="highlighter-rouge">pushParamWInd</code> (to
extract value from memory location pointed by parameter).</p>

<h2 id="global-importables">Global importables</h2>
<p>Macros and functions from <code class="highlighter-rouge">c64lib</code> are declared within <code class="highlighter-rouge">c64lib</code> namespace. As
already mentioned this is to avoid name clashes when using libraries from
different sources. Due to KickAssembler limitations it is not possible to
access macro or function from within namespace using “dot” notation. In order
to allow accessing elements from outside <code class="highlighter-rouge">c64lib</code> namespace, each library file
has <code class="highlighter-rouge">_global</code> counterpart that can be alternatively imported. In such case
all elements such as functions and macros will be available straight from
root namespace by using <code class="highlighter-rouge">c64lib_</code> name prefix.</p>

<p>Example - you can use elements from <a href="https://github.com/c64lib/common/blob/master/lib/invoke.asm">invoke</a> in traditional way:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#import "common/lib/invoke.asm"

.namespace c64lib {
    pushParamW(sourceAddress)
    pushParamW(destinationAddress)
    pushParamW(amountOfBytesToCopy)
}
</code></pre></div></div>

<p>or by using global importable:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#import "common/lib/invoke-global.asm"

c64lib_pushParamW(sourceAddress)
c64lib_pushParamW(destinationAddress)
c64lib_pushParamW(amountOfBytesToCopy)
</code></pre></div></div>



</article>


	  </main>

		  <!-- Pagination links -->
      

	  </div>

	    <!-- Footer -->
	    <footer><span>&#169; 2018-2020 <code>c64lib</code> &#10540; last update: 2020-01-04 22:38</span></footer>


		

	    <!-- Script -->
      <script src="/jekyll-starter/js/main.js"></script>	


	</div>

</body>
</html>
